# 短信事件参数统一规范

## 概述

为了实现不同短信服务商之间的兜底和容错，所有短信库的 `SmsEventConsumer` 使用统一的参数结构。当某个短信服务商发送失败时，后续的服务商可以使用相同的参数重新发送。

## 统一参数结构

以 FengHuo（烽火）短信库的参数为基准，定义如下统一参数：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| `mobiles` | String | 是 | 手机号，多个手机号使用逗号分隔 |
| `content` | String | 否 | 短信内容（直接发送内容时使用） |
| `templateId` | String/Int32 | 否 | 模板ID（字符串或数字格式） |
| `paramValues` | IDictionary<String, String> | 否 | 模板参数（键值对字典） |
| `callData` | String | 否 | 回调数据 |
| `sendTime` | String | 否 | 定时发送时间 |
| `extcode` | String | 否 | 扩展码 |
| `sessionContext` | String | 否 | 会话上下文（腾讯云特有） |
| `senderId` | String | 否 | 发送者ID（腾讯云特有） |

## 各短信库参数映射

### FengHuo（烽火）

直接使用统一参数，无需映射。

### Aliyun（阿里云）

| 统一参数 | 阿里云参数 | 说明 |
|----------|------------|------|
| `mobiles` | `Phone` | 手机号列表 |
| `templateId` | `TemplateCode` | 模板代码 |
| `paramValues` | `TemplateParams` | 模板参数 |

**实现逻辑：**
```csharp
var message = new AliyunDysmsMessage
{
    Phone = [.. mobiles.Split(',', StringSplitOptions.RemoveEmptyEntries)],
    TemplateCode = templateId,
    TemplateParams = paramValues
};
```

### TencentCloud（腾讯云）

| 统一参数 | 腾讯云参数 | 说明 |
|----------|------------|------|
| `mobiles` | `mobiles` | 手机号 |
| `paramValues` | `templateParams` | 模板参数（转为数组） |
| `templateId` | `templateId` | 模板ID |
| `extcode` | `extendCode` | 扩展码 |
| `sessionContext` | `sessionContext` | 会话上下文 |
| `senderId` | `senderId` | 发送者ID |

**实现逻辑：**
```csharp
var templateParams = paramValues?.Values.ToArray();

await client.SendAsync(
    mobiles,
    templateParams,
    templateId,
    extcode,
    sessionContext,
    senderId
);
```

### LianLu（联麓）

| 统一参数 | 联麓参数 | 说明 |
|----------|----------|------|
| `mobiles` | `mobiles` | 手机号 |
| `content` | `content` | 短信内容 |

**实现逻辑：**
```csharp
await client.SendAsync(mobiles, content);
```

## 兜底机制

通过 `SmsData.Order` 和 `SmsEventConsumer.Sort` 控制执行顺序：

| 短信服务商 | Order/Sort | 优先级 |
|------------|------------|--------|
| FengHuo（烽火） | 10 | 最高 |
| Aliyun（阿里云） | 20 | 第二 |
| TencentCloud（腾讯云） | 30 | 第三 |
| LianLu（联麓） | 40 | 最低 |

**工作流程：**
1. 首先尝试使用 Order=10 的 FengHuo 发送
2. 如果 FengHuo 失败，事件 `Success=false`，继续传递
3. Order=20 的 Aliyun 接管，使用统一参数重新发送
4. 以此类推，直到发送成功或所有服务商都失败

## 示例代码

### 发送短信事件

```csharp
var eventData = new Dictionary<String, Object>
{
    ["mobiles"] = "13800138000,13900139000",
    ["content"] = "您的验证码是123456",
    ["templateId"] = "SMS_123456",
    ["paramValues"] = new Dictionary<String, String>
    {
        ["code"] = "123456",
        ["product"] = "沛柯智能"
    }
};

var smsEvent = new SmsEvent(eventData);
await eventBus.PublishAsync(smsEvent);
```

### 消费者处理

```csharp
public async Task HandleEventAsync(SmsEvent eventMessage)
{
    if (eventMessage.Success) return;

    // 获取统一参数
    var mobiles = eventMessage.Data?["mobiles"]?.SafeString();
    var content = eventMessage.Data?["content"]?.SafeString();
    var templateId = eventMessage.Data?["templateId"]?.SafeString();
    var paramValues = eventMessage.Data?["paramValues"] as IDictionary<String, String>;
    
    // 根据当前服务商的需求进行转换和发送
    // ...
}
```

## 注意事项

1. **参数完整性**：发送短信事件时，应尽可能提供完整的参数，以确保所有服务商都能正确处理
2. **参数兼容**：各服务商的 EventConsumer 应容错处理缺失的参数，只有必填参数缺失时才返回
3. **Order 配置**：`SmsData.Order` 可在配置文件中调整，实现动态的优先级控制
4. **Sort 初始化**：`SmsEventConsumer.Sort` 从配置中读取 Order 值，确保与配置一致

## 配置示例

```json
{
  "Data": [
    {
      "Code": "xxx",
      "Name": "fenghuo",
      "DisplayName": "烽火",
      "SmsType": 0,
      "Order": 10,
      "IsEnabled": true,
      "AccessKey": "your-access-key",
      "AccessSecret": "your-access-secret",
      "SignName": "沛柯智能"
    },
    {
      "Code": "yyy",
      "Name": "aliyun",
      "DisplayName": "阿里云",
      "SmsType": 0,
      "Order": 20,
      "IsEnabled": true,
      "AccessKey": "your-access-key",
      "AccessSecret": "your-access-secret",
      "SignName": "沛柯智能"
    }
  ]
}
```

---

**维护说明**：如需添加新的短信服务商，请遵循本规范，使用统一参数结构，确保兜底机制正常工作。
